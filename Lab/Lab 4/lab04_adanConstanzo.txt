--1
--If the person was born after 1995, they are "GenerationZ". 
--Else if the person was born after 1980, they are "Millennial".
-- Else if they were born after 1965 they are "GenerationX". 
--Else if they were born after 1945 they are "BabyBoomer". 
--Else if they were born after 1933 they are "The Silent Generation". 
--Otherwise they are "The Greatest Generation". 

generation gen  
  | gen > 1995 = "Generation Z"
  | gen > 1980 = "Millennial"
  | gen > 1965 = "Generation X"
  | gen > 1945 = "BabyBoomer"
  | gen > 1933 = "The Silent Generation"  
  | otherwise   = "The Greatest Generation"

--2
--2 pts) Write a function just like the above named generation2, 
--except the input is a person's age in years. 
--The guards check a variable that has the birth year of the person and assigns 
--them to generations as indicated above, but at the end there is a where clause 
--that converts the age to the birth year.
generation2 :: Int-> String
generation2 age
  | gen > 1995 = "Generation Z"
  | gen > 1980 = "Millennial"
  | gen > 1965 = "Generation X"
  | gen > 1945 = "BabyBoomer"
  | gen > 1933 = "The Silent Generation"  
  | otherwise   = "The Greatest Generation"
  where gen = 2017 - age

--3
--2 pts) Write a function that takes in a list of 2-place tuples of floats 
--(that represent two smaller sides of a right triangle) and converts it to its 
--corresponding hypotenuse. Use a function definition in a where clause. Btw, to 
--get the square root of a float, use sqrt function.
hypo :: (RealFloat a) => [(a, a)] -> [a]  
hypo xs = [hyp l r | (l, r) <- xs]  
    where hyp left right = sqrt (left^2+right^2)

--4
--2 pts) Complete a function that takes an Float a and a list of Floats. 
--Use list comprehension to multiply each value in the list by pi * a. Use let to get p*a.
calc x xs = [z * w | (w) <- xs, let z = x * pi]

--5
-- Take this function: 
--Using list pattern matching, create a function that multiplies the 
-- three elements of a list  of Ints (or all the elements, if the list has 3 or 
--less elements, 0 if the list is empty) and returns the product. 
--Use cases for the pattern matching instead of separate function bodies.

multList :: [Int] -> Int
multList xs = case xs of [] ->  0
                         (x:[]) ->x
                         (x:y:[]) -> x*y
                         (x:y:z:xs) -> x*y*z